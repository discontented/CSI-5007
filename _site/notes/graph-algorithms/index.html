<!DOCTYPE html>
<html lang=" en "><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Graph Algorithms | Algorithms</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Graph Algorithms" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Basics Graph Symbols Runtime Analysis Principle of Optimality Graph Representations Adjacency Matrix When to use Adjacency Matrix Incidence Matrix Weighted Graph Representation Adjacency List Graph Traversal Key Ideas Vertex States Breadth First Search Application Properties Steps Psuedocode Runtime Depth First Search (DFS) Applications Properties Stack Predecessor Graph Steps DFS Strategies Pre-order In-order INCOMPLETE Post-Order Pseudocode Python Implementation Iterative Recursive Runtime Union-Find Data Structure Methods Minimum Spanning Trees (MST) Prim’s Algorithm Pseudocode Kruskal’s Algorithm Pseudocode Shortest Path Properties Input Shortest Path Problem Predecessor Graph Relaxation Dijkstra’s Algorithm Process Runtime Bellman-Ford Efficiency Algorithm Floyd-Warshall Algorithm Runtime Topological Sort Runtime" />
<meta property="og:description" content="Basics Graph Symbols Runtime Analysis Principle of Optimality Graph Representations Adjacency Matrix When to use Adjacency Matrix Incidence Matrix Weighted Graph Representation Adjacency List Graph Traversal Key Ideas Vertex States Breadth First Search Application Properties Steps Psuedocode Runtime Depth First Search (DFS) Applications Properties Stack Predecessor Graph Steps DFS Strategies Pre-order In-order INCOMPLETE Post-Order Pseudocode Python Implementation Iterative Recursive Runtime Union-Find Data Structure Methods Minimum Spanning Trees (MST) Prim’s Algorithm Pseudocode Kruskal’s Algorithm Pseudocode Shortest Path Properties Input Shortest Path Problem Predecessor Graph Relaxation Dijkstra’s Algorithm Process Runtime Bellman-Ford Efficiency Algorithm Floyd-Warshall Algorithm Runtime Topological Sort Runtime" />
<link rel="canonical" href="http://localhost:4000/CSI-5007/notes/graph-algorithms/" />
<meta property="og:url" content="http://localhost:4000/CSI-5007/notes/graph-algorithms/" />
<meta property="og:site_name" content="Algorithms" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-24T20:49:15-04:00" />
<script type="application/ld+json">
{"description":"Basics Graph Symbols Runtime Analysis Principle of Optimality Graph Representations Adjacency Matrix When to use Adjacency Matrix Incidence Matrix Weighted Graph Representation Adjacency List Graph Traversal Key Ideas Vertex States Breadth First Search Application Properties Steps Psuedocode Runtime Depth First Search (DFS) Applications Properties Stack Predecessor Graph Steps DFS Strategies Pre-order In-order INCOMPLETE Post-Order Pseudocode Python Implementation Iterative Recursive Runtime Union-Find Data Structure Methods Minimum Spanning Trees (MST) Prim’s Algorithm Pseudocode Kruskal’s Algorithm Pseudocode Shortest Path Properties Input Shortest Path Problem Predecessor Graph Relaxation Dijkstra’s Algorithm Process Runtime Bellman-Ford Efficiency Algorithm Floyd-Warshall Algorithm Runtime Topological Sort Runtime","@type":"BlogPosting","url":"http://localhost:4000/CSI-5007/notes/graph-algorithms/","headline":"Graph Algorithms","dateModified":"2018-06-24T20:49:15-04:00","datePublished":"2018-06-24T20:49:15-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/CSI-5007/notes/graph-algorithms/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/CSI-5007/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/CSI-5007/feed.xml" title="Algorithms" /></head>


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/CSI-5007/">Algorithms</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/CSI-5007/about/">About</a></div>
      </nav></div>
</header>
<form id='search' action="/CSI-5007/search.html" method="get">
        <label for="search-box">Search</label>
        <input type="text" id="search-box" name="query">
        <input type="submit" value="search">
      </form>

    <main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Graph Algorithms</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-06-24T20:49:15-04:00" itemprop="datePublished">Jun 24, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul>
  <li><a href="#basics">Basics</a>
    <ul>
      <li><a href="#graph-symbols">Graph Symbols</a></li>
      <li><a href="#runtime-analysis">Runtime Analysis</a></li>
      <li><a href="#principle-of-optimality">Principle of Optimality</a></li>
    </ul>
  </li>
  <li><a href="#graph-representations">Graph Representations</a>
    <ul>
      <li><a href="#adjacency-matrix">Adjacency Matrix</a>
        <ul>
          <li><a href="#when-to-use-adjacency-matrix">When to use Adjacency Matrix</a></li>
        </ul>
      </li>
      <li><a href="#incidence-matrix">Incidence Matrix</a>
        <ul>
          <li><a href="#weighted-graph-representation">Weighted Graph Representation</a></li>
        </ul>
      </li>
      <li><a href="#adjacency-list">Adjacency List</a></li>
    </ul>
  </li>
  <li><a href="#graph-traversal">Graph Traversal</a>
    <ul>
      <li><a href="#key-ideas">Key Ideas</a>
        <ul>
          <li><a href="#vertex-states">Vertex States</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#breadth-first-search">Breadth First Search</a>
    <ul>
      <li><a href="#application">Application</a></li>
      <li><a href="#properties">Properties</a></li>
      <li><a href="#steps">Steps</a></li>
      <li><a href="#psuedocode">Psuedocode</a></li>
      <li><a href="#runtime">Runtime</a></li>
    </ul>
  </li>
  <li><a href="#depth-first-search-dfs">Depth First Search (DFS)</a></li>
  <li><a href="#applications">Applications</a>
    <ul>
      <li><a href="#properties-1">Properties</a></li>
      <li><a href="#stack">Stack</a></li>
      <li><a href="#predecessor-graph">Predecessor Graph</a></li>
      <li><a href="#steps-1">Steps</a></li>
      <li><a href="#dfs-strategies">DFS Strategies</a>
        <ul>
          <li><a href="#pre-order">Pre-order</a></li>
          <li><a href="#in-order-incomplete">In-order <strong>INCOMPLETE</strong></a></li>
          <li><a href="#post-order">Post-Order</a></li>
        </ul>
      </li>
      <li><a href="#pseudocode">Pseudocode</a></li>
      <li><a href="#python-implementation">Python Implementation</a>
        <ul>
          <li><a href="#iterative">Iterative</a></li>
          <li><a href="#recursive">Recursive</a></li>
        </ul>
      </li>
      <li><a href="#runtime-1">Runtime</a></li>
    </ul>
  </li>
  <li><a href="#union-find-data-structure">Union-Find Data Structure</a>
    <ul>
      <li><a href="#methods">Methods</a></li>
    </ul>
  </li>
  <li><a href="#minimum-spanning-trees-mst">Minimum Spanning Trees (MST)</a>
    <ul>
      <li><a href="#prims-algorithm">Prim’s Algorithm</a>
        <ul>
          <li><a href="#pseudocode-1">Pseudocode</a></li>
        </ul>
      </li>
      <li><a href="#kruskals-algorithm">Kruskal’s Algorithm</a>
        <ul>
          <li><a href="#pseudocode-2">Pseudocode</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#shortest-path">Shortest Path</a>
    <ul>
      <li><a href="#properties-2">Properties</a></li>
      <li><a href="#input">Input</a></li>
      <li><a href="#shortest-path-problem">Shortest Path Problem</a></li>
      <li><a href="#predecessor-graph-1">Predecessor Graph</a></li>
      <li><a href="#relaxation">Relaxation</a></li>
      <li><a href="#dijkstras-algorithm">Dijkstra’s Algorithm</a>
        <ul>
          <li><a href="#process">Process</a></li>
          <li><a href="#runtime-2">Runtime</a></li>
        </ul>
      </li>
      <li><a href="#bellman-ford">Bellman-Ford</a>
        <ul>
          <li><a href="#efficiency">Efficiency</a></li>
          <li><a href="#algorithm">Algorithm</a></li>
        </ul>
      </li>
      <li><a href="#floyd-warshall-algorithm">Floyd-Warshall Algorithm</a>
        <ul>
          <li><a href="#runtime-3">Runtime</a></li>
        </ul>
      </li>
      <li><a href="#topological-sort">Topological Sort</a>
        <ul>
          <li><a href="#runtime-4">Runtime</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="basics">Basics</h1>

<ul>
  <li>Graph $G=(V,E)$ contains $n$ vertices and $m$ edges
    <ul>
      <li>Vertices are also called <strong>nodes</strong></li>
    </ul>
  </li>
  <li><strong>Directed Graph</strong>
    <ul>
      <li>AKA di-graph</li>
      <li>$(u,v)\ne (v,u)$</li>
    </ul>
  </li>
  <li><strong>Weighted graph</strong>
    <ul>
      <li>Each edge of a graph has an associated weight.</li>
      <li>Weight is given by a weight function $w:E\rightarrow \mathbb{R}$</li>
    </ul>
  </li>
</ul>

<h2 id="graph-symbols">Graph Symbols</h2>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$G$</td>
      <td>Graph</td>
    </tr>
    <tr>
      <td>$V$</td>
      <td>Set of vertices</td>
    </tr>
    <tr>
      <td>$E$</td>
      <td>Set of edges</td>
    </tr>
    <tr>
      <td>$u$ or $v$</td>
      <td>Vertex/Node</td>
    </tr>
    <tr>
      <td>$(u,v)$</td>
      <td>Edge</td>
    </tr>
    <tr>
      <td>$w(u,v)$</td>
      <td>Weight of edge</td>
    </tr>
    <tr>
      <td>$s$</td>
      <td>Source Vertex</td>
    </tr>
    <tr>
      <td>$v.\pi$</td>
      <td>Predecessor</td>
    </tr>
    <tr>
      <td>$G_\pi =(V_\pi ,E_\pi)$</td>
      <td>Predecessor Subgraph</td>
    </tr>
    <tr>
      <td>$p=\langle{v_0,v_1,…v_k}\rangle$</td>
      <td>Path</td>
    </tr>
    <tr>
      <td>$c=\langle{v_i,v_{i+1},…,v_j}\rangle, v_i=v_j$</td>
      <td>Cycle</td>
    </tr>
    <tr>
      <td>$G’=(V’,E’)$</td>
      <td>Shortest-Paths Tree</td>
    </tr>
  </tbody>
</table>

<h2 id="runtime-analysis">Runtime Analysis</h2>
<ul>
  <li>The runtime of a graph algorithm for a given graph $G=(V,E)$ is measured in terms of the number of vertices ($\lvert V\rvert$) and number of edges ($\lvert E\rvert$)</li>
  <li>Inside asymptotic notation, the cardinality is ommitted.
    <ul>
      <li>$\Theta(\lvert V\rvert, \lvert E\rvert)\equiv \Theta(V, E)$</li>
    </ul>
  </li>
</ul>

<h2 id="principle-of-optimality">Principle of Optimality</h2>
<blockquote>
  <p>If $v_1,…,v_j,…,v_k$ is a shortest path from $v_1$ to $v_k$ passing through $v_j$, then the subpath $v_1,…,v_j$ is a shortest path from $v_1$ to $v_j$</p>
</blockquote>

<h1 id="graph-representations">Graph Representations</h1>

<table>
  <thead>
    <tr>
      <th>Graph</th>
      <th>Data Structure</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sparse Graph $(\lvert E\rvert « {\lvert V\rvert}^2)$</td>
      <td><a href="#adjacency-list">Adjacency List</a></td>
    </tr>
    <tr>
      <td>Dense Graph $(\lvert E\rvert « {\lvert V\rvert}^2)$</td>
      <td><a href="#adjacency-matrix">Adjancency Matrix</a></td>
    </tr>
  </tbody>
</table>

<h2 id="adjacency-matrix">Adjacency Matrix</h2>
<p><img src="https://process.filestackapi.com/cache=expiry:max/dTLEaB3Q3GVvB0buaLp3" alt="adjacency matrix" /></p>

<ul>
  <li>$G$ is represented by a $\lvert{V}\rvert \times \lvert{V}\rvert$ matrix $M_{i,j}$</li>
  <li>$1$ represents an edge between vertex $i$ and $j$</li>
  <li>$0$ represents no edge between vertices.</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
M[i,j]=
\begin{cases}
1 & \text{if $(i,j)$ is an edge of $G$} \\
0 & \text{if $(i,j)$ is not an edge of $G$}
\end{cases} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
M[i,j]=
\begin{array}{} j\\
i
\begin{bmatrix}
0 & 1\\
1 & 0
\end{bmatrix}
\end{array} %]]></script>

<ul>
  <li>$i$ - Source Vertex</li>
  <li>$j$ - Destination Vertex</li>
</ul>

<h3 id="when-to-use-adjacency-matrix">When to use Adjacency Matrix</h3>
<ul>
  <li>Pros
    <ul>
      <li>Rapid search for edges in graph</li>
      <li>Rapid update to edge insertion and deletion</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>Uses excessive space for graphs with many vertices and few edges</li>
    </ul>
  </li>
</ul>

<h2 id="incidence-matrix">Incidence Matrix</h2>
<ul>
  <li>A directed graph with no self-loops.</li>
  <li>Matrix $B=\lvert{V}\rvert\times\lvert{E}\rvert$</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
b_{i,j}=\begin{cases}
-1 & \text{if edge $j$ leaves vertex $i$} \\
1 & \text{if edge $j$ enters vertex $i$} \\
0 & \text{otherwise}
\end{cases} %]]></script>

<h3 id="weighted-graph-representation">Weighted Graph Representation</h3>
<ul>
  <li><code class="highlighter-rouge">adj[i][j] = w</code>
      * Weighted graphs represented in an adjacency matrix displays the weight instead of 1 for an edge</li>
</ul>

<h2 id="adjacency-list">Adjacency List</h2>
<p><img src="https://process.filestackapi.com/cache=expiry:max/Ah1Snl5rTECuaVKfU951" alt="adjacency list" /></p>

<ul>
  <li>Pros
    <ul>
      <li>More efficiently stores sparse graphs</li>
    </ul>
  </li>
  <li>Cons
    <ul>
      <li>Slower to find edge as it is necessary to search from head of linked list to find edge.</li>
    </ul>
  </li>
</ul>

<h1 id="graph-traversal">Graph Traversal</h1>

<h2 id="key-ideas">Key Ideas</h2>
<ul>
  <li>Mark every vertex which is visted to keep track of if the graph has been completely explored.
    <ul>
      <li>There are numerous implementations of this, such as tracking visited nodes by adding to an array, or changing the state on the property of a vertex if it is coded as an object.</li>
    </ul>
  </li>
</ul>

<h3 id="vertex-states">Vertex States</h3>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>undiscovered</td>
      <td>Vertex is in its initial state and has not been visited.</td>
    </tr>
    <tr>
      <td>discovered</td>
      <td>Vertex has been found but incident edges have not been checked.</td>
    </tr>
    <tr>
      <td>processed</td>
      <td>Vertex where all incident edges have been visited.</td>
    </tr>
  </tbody>
</table>

<h1 id="breadth-first-search">Breadth First Search</h1>
<p><img src="https://ds055uzetaobb.cloudfront.net/image_optimizer/62cdd0cb92ee8629cb1422e04d76a12da176bd02.gif" alt="bfs brilliant" /></p>

<h2 id="application">Application</h2>
<ul>
  <li>Finding optimal solution out of available options.
    <ul>
      <li>Find connected components</li>
    </ul>
  </li>
  <li>Find shortest path in unweighted graphs.</li>
  <li>Test for bipartite property.</li>
</ul>

<h2 id="properties">Properties</h2>
<ul>
  <li>Builds a breadth-first tree with root $s$
    <ul>
      <li>$s$ - A distinguished source vertex.</li>
    </ul>
  </li>
  <li>Explores edges of $G$ to <strong>discover</strong> every vertex that is reachable from $s$.
    <ul>
      <li>Vertex is <strong>discovered</strong> the first time it is encountered in a search.</li>
    </ul>
  </li>
  <li>Distance ($d$) is the shortest path from any vertex $v$ to the source vertex $s$</li>
  <li>Algorithm discovers all vertices at distance $k$ from $s$ before discovering any vertices at $d = k + 1$</li>
  <li>$u.\pi$ represents the predecessor of $u$ in book psuedocode.</li>
  <li>Uses a queue
    <ul>
      <li>Stores discvored by not processed vertices in FIFO order.
        <ul>
          <li>Explore the oldest unexplored vertices first.
            <h2 id="steps">Steps</h2>
            <ol>
              <li>Pick source vertex, <code class="highlighter-rouge">s</code>, from graph.
                <ol>
                  <li><code class="highlighter-rouge">s</code> becomes the root of the tree.</li>
                </ol>
              </li>
              <li>Look at each neighbor in an order.</li>
              <li>Visit each neighbor vertex in that same order.</li>
              <li>Repeat breadth-first search for each <code class="highlighter-rouge">k+1</code> vertex from <code class="highlighter-rouge">s</code></li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="psuedocode">Psuedocode</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BFS(G, s)
	for each vertex $u\in V[G] - {s}$ do
		state[u] = "undiscovered"
		p[u] = nil //no parent is in BFS tree
	state[s] = "discovered"
	p[s] = nil
	Q = {s}
	while Q != $\emptyset$ do
		u = dequeue[Q]
		process vertex u as desired
		for each $v \in Adj[u]$ do
			process edge $(u,v)$ as desired
			if state[v] = "undiscovered" then
				state[v] = discovered"
				p[v] = u
				enqueue[Q, v]
		state[u] = "processed"
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">p[*]</code> represents predecessor of vertex</li>
  <li>A vertex is <strong>discovered</strong> the first time it is visited.</li>
  <li>A vertex is <strong>processed</strong> after all outgoing edges from it have been traversed.</li>
</ul>

<h2 id="runtime">Runtime</h2>
<p>$O(n + m)$</p>

<h1 id="depth-first-search-dfs">Depth First Search (DFS)</h1>
<p><img src="https://ds055uzetaobb.cloudfront.net/image_optimizer/35a0e3d657f653ec7b3c6113ad4b55264cae5516.gif" alt="dfs" /></p>

<h1 id="applications">Applications</h1>
<ul>
  <li>Connnected components</li>
  <li>Topological Sorting
    <ul>
      <li><strong>Topological Sort</strong>
        <ul>
          <li>Linear ordering of its vertices such that for every directed edge $uv$ from vertex $u$ to vertex $v$, $u$ comes before $v$ in the ordering.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Finding cycles in directed graphs</li>
</ul>

<h2 id="properties-1">Properties</h2>
<ul>
  <li>Finds the longest path of a graph $G$</li>
  <li>Explores deep into a graph whenever possible.</li>
  <li>Uses a stack to keep track of vertices.</li>
  <li>Explores edges out of the most recently discovered vertex $v$ that still has unexplored edges leaving it.</li>
  <li>Once $v$’s edges have been explored, the search backtracks to explore edges leaving the vertex from which $v$ was discovered.
    <ul>
      <li>Backs up when surrounded by previously discovered vertices.</li>
    </ul>
  </li>
  <li>Continues until all vertices $v$ that are reachable from the original source vertex $s$ have been discovered.</li>
  <li>Algorithm repeats process until it has discovered very vertex.</li>
</ul>

<h2 id="stack">Stack</h2>
<ul>
  <li>Stores discovered but not processed vertices.</li>
  <li>LIFO</li>
</ul>

<h2 id="predecessor-graph">Predecessor Graph</h2>
<ul>
  <li>Whenever a DFS discovers a vertex $v$ during a scan of an already discovered vertex $u$, it sets $v$’s predecessor attribute $v.\pi$ to $u$</li>
  <li>The predecessor subgraph produced by a DFS forms a <strong>predecessor forest</strong> because the search may repeat from multiple source ($s$) vertices</li>
</ul>

<p><em>Predecessor Subgraph Representation</em></p>

<script type="math/tex; mode=display">G_{\pi}=(V,E_{\pi}), \text{where } E_{\pi}={(v.\pi,v):v\in V \text{and } v.\pi \neq NIL}</script>

<h2 id="steps-1">Steps</h2>
<ol>
  <li>Visit a vertex $s$</li>
  <li>Mark $s$ as visited</li>
  <li>Recursively visit each unvisited vertex attached to $s$</li>
</ol>

<h2 id="dfs-strategies">DFS Strategies</h2>
<h3 id="pre-order">Pre-order</h3>
<ul>
  <li>Visit source node $s$.</li>
  <li>Successively move left to visit each node ($v$) until a leaf is reached.</li>
  <li>When there are no more children to left of $s$ node.</li>
</ul>

<h3 id="in-order-incomplete">In-order <strong>INCOMPLETE</strong></h3>
<ul>
  <li>Find left-most node in tree and visit.</li>
  <li>Vist the parent of that node.</li>
  <li>Visit right child of this parent node.
    <ul>
      <li>Find next left-most node.</li>
    </ul>
  </li>
</ul>

<h3 id="post-order">Post-Order</h3>
<ul>
  <li>Visit left-most leaf in tree.</li>
  <li>Visit parent and then find second left-most leaf.</li>
  <li>Repeat until the parent is the last node within a branch.</li>
</ul>

<h2 id="pseudocode">Pseudocode</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Initialize an empty stack for storage of nodes, S.
For each vertex u, define u.visited to be false.
Push the root (first node to be visited) onto S.
While S is not empty:
	Pop the first element in S, u.
	If u.visited = false, then:
		U.visited = true
		for each unvisited neighbor w of u:
			Push w into S.
End process when all nodes have been visited.
</code></pre></div></div>

<h2 id="python-implementation">Python Implementation</h2>
<h3 id="iterative">Iterative</h3>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">depth_first_search</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
	<span class="n">visited</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
	<span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
		<span class="n">vertex</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
			<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
			<span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">visited</span>
</code></pre></div></div>

<h3 id="recursive">Recursive</h3>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">depth_first_search_recursive</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
	<span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
	<span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span><span class="p">:</span>
		<span class="n">depth_first_search_recursive</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">visited</span>
</code></pre></div></div>

<h2 id="runtime-1">Runtime</h2>
<p>If using a adjacency list, $O(V+E)$</p>

<h1 id="union-find-data-structure">Union-Find Data Structure</h1>

<h2 id="methods">Methods</h2>
<ul>
  <li><code class="highlighter-rouge">init(a)</code>
    <ul>
      <li>Create the data structure of $n$ elements</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">find(v)</code>
    <ul>
      <li>Returns head of tree containing $v$</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">union(u,v)</code>
    <ul>
      <li>Attach the tree of $u$ to the tree of $v$</li>
    </ul>
  </li>
  <li>Checking if two vertices are part of seperate trees is simple.</li>
  <li>This method is used in Kruskal’s algorithm when creating and joining trees.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if find(v) == find(u)
  v and u are part of the same tree
elif find(v) != find(u)
  v and u are part of different trees
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="minimum-spanning-trees-mst">Minimum Spanning Trees (MST)</h1>
<ul>
  <li>Works on a connected, weighted, undirected graph</li>
  <li><strong>Spanning Tree</strong>
    <ul>
      <li>An acyclic subset, or tree, $T$ of a graph that connects all vertices from a vertex $u$ to $v$</li>
    </ul>
  </li>
  <li><strong>Minimum Spanning Tree</strong>
    <ul>
      <li><strong>Unweighted Graph</strong>
        <ul>
          <li>Tree that minimizes the number of edges.</li>
        </ul>
      </li>
      <li><strong>Weighted Graph</strong>
        <ul>
          <li>Tree that minimizes the weights of edges</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="prims-algorithm">Prim’s Algorithm</h2>
<ul>
  <li>Starts from one vertex and grows the rest of the tree one edge at a time until all vertices are included.</li>
  <li><a href="/CSI-5007/notes/algorithms-basics/#greedy-algorithms">Greedy</a>
    <ul>
      <li>Repeatedly selects the smallest weight edge at a vertex.</li>
    </ul>
  </li>
</ul>

<ol>
  <li>Start from a given vertex $s$
    <ol>
      <li>This is root of a spanning tree $T$</li>
    </ol>
  </li>
  <li>With each iteration add a new vertex to the spanning tree $T$.
    <ol>
      <li>Always add the lowest-weight edge linking a vertex in the tree to a vertex outside of the tree.</li>
    </ol>
  </li>
</ol>

<h3 id="pseudocode-1">Pseudocode</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Prim-MST(G)
  Select an arbitrary vertex s to start the tree from
	while (there are still nontree vertices)
	  Select the edge of minimum weight between a tree and nontree vertex
	  Add the selected edge and vertext to the tree T
</code></pre></div></div>

<h2 id="kruskals-algorithm">Kruskal’s Algorithm</h2>
<ul>
  <li>The safe edge added to $A$ is always a least-weight edge in the graph that connects two distinct components.</li>
  <li>Greedy
    <ul>
      <li>At each step it adds to the forest an edge of least possible weight.</li>
    </ul>
  </li>
  <li>More efficient than Prim’s on sparse graphs.</li>
</ul>

<h3 id="pseudocode-2">Pseudocode</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MST-Kruskal(Graph, weight):
	A = []
	for each vertex (v) in Graph.vertices
		MakeSet(v)
	sort edges of G.E into non-decreasing order by weight
		if FindSet(u) != FindSet(v):
			A = A.append{(u, v)}
			Union(u,v)
	return A
</code></pre></div></div>

<h1 id="shortest-path">Shortest Path</h1>
<ul>
  <li>Given a weighted, directed graph, find the shortest path from a given <strong>source</strong> vertex.
    <ul>
      <li>$s\in V$</li>
    </ul>
  </li>
</ul>

<h2 id="properties-2">Properties</h2>
<ul>
  <li>Edges have weights.
    <ul>
      <li><a href="#dijkstras-algorithm">Dijkstra’s</a> does not work with negative weights.</li>
      <li>Edges can be directed or undirected.</li>
    </ul>
  </li>
</ul>

<h2 id="input">Input</h2>
<ul>
  <li>$G$ - Graph
    <ul>
      <li>Made up of a set of vertices $V$ and set of edges $E$.</li>
    </ul>
  </li>
  <li>$s$ - Source vertex</li>
  <li>$t$ - Destination vertex</li>
</ul>

<h2 id="shortest-path-problem">Shortest Path Problem</h2>
<ul>
  <li>Given two points, $s$ and $t$, what is the shortest path between them.</li>
</ul>

<h2 id="predecessor-graph-1">Predecessor Graph</h2>
<ul>
  <li>$v.\pi$ represents the predecessor vertex of $v$
    <ul>
      <li>Its value is either another vertex or <code class="highlighter-rouge">null</code></li>
      <li>Represented by <code class="highlighter-rouge">v.p</code> in code</li>
    </ul>
  </li>
</ul>

<h2 id="relaxation">Relaxation</h2>
<ul>
  <li>$v.d$
    <ul>
      <li>Upper bound on the weight of the shortest path from source $s$ to $v$</li>
      <li>Known as the <strong>shortest-path estimate</strong></li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Relax(u,v,w)
	if v.d &gt; u.d + w(u,v)
		v.d = u.d + w(u,v)
		v.p = u
</code></pre></div></div>

<h2 id="dijkstras-algorithm">Dijkstra’s Algorithm</h2>
<ul>
  <li>Greedy</li>
  <li>Does not work with negative weights</li>
</ul>

<h3 id="process">Process</h3>
<ol>
  <li>Select a root node $s$ that forms a tree $T$</li>
  <li>$s.d[]$ is the array of distances of every node to $s$</li>
  <li>While $T$ does not span $G$
    <ol>
      <li>Pick a node $v$ of minimum distance in $d$
        <ol>
          <li>$v = min{s.d}$</li>
        </ol>
      </li>
      <li>Add node $v$ to $T$</li>
      <li>Update the distance vector $s.d$ of neighbors of $v$ if the distance can be lowered from its previous value.</li>
    </ol>
  </li>
</ol>

<h3 id="runtime-2">Runtime</h3>
<p>$O(\lvert{V}\rvert^2)$</p>

<h2 id="bellman-ford">Bellman-Ford</h2>
<ul>
  <li>Works with edges with negative weights.</li>
  <li>Graph is directed.</li>
  <li>Uses a boolean to check if a negative-weight cycle is reachable from the source.
    <ul>
      <li>If so, there is no solution.</li>
      <li>If there is no cycle, the algorithm returns the shortest paths and their weights.</li>
    </ul>
  </li>
</ul>

<h3 id="efficiency">Efficiency</h3>
<p>$O(|V|^3)$</p>

<h3 id="algorithm">Algorithm</h3>
<ul>
  <li>Decreases estimates of $v.d$ on the weight of the shortest path from the source $s$ to each vertex $v\in V$ until the actual shortest-path is found.</li>
</ul>

<h2 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h2>
<ul>
  <li>Dynamic Programming</li>
  <li>Works with negative weights.</li>
</ul>

<h3 id="runtime-3">Runtime</h3>
<p>$O(|V|^3)$</p>

<h2 id="topological-sort">Topological Sort</h2>
<ul>
  <li>For directed acyclic graphs (DAGs)</li>
  <li>Ordering of all vertices such that for each edge $(u,v)\in E$, $u$ comes before $v$</li>
</ul>

<h3 id="runtime-4">Runtime</h3>
<p>$O(n)$</p>

  </div><a class="u-url" href="/CSI-5007/notes/graph-algorithms/" hidden></a>
</article>

        </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/CSI-5007/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Algorithms</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Algorithms</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/josh-corneille"><svg class="svg-icon"><use xlink:href="/CSI-5007/assets/minima-social-icons.svg#github"></use></svg> <span class="username">josh-corneille</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>CSI 5007 Notes</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>