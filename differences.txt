Files GitHub/code-CSI-5007/notes/_notes/class-code.md and GitHub/CSI-5007/_notes/class-code.md differ
Common subdirectories: GitHub/code-CSI-5007/notes/_notes/class_notes and GitHub/CSI-5007/_notes/class_notes
Files GitHub/code-CSI-5007/notes/_notes/dynamic-programming.md and GitHub/CSI-5007/_notes/dynamic-programming.md differ
Only in GitHub/CSI-5007/_notes/: final.md
Files GitHub/code-CSI-5007/notes/_notes/graph-algorithms.md and GitHub/CSI-5007/_notes/graph-algorithms.md differ
Only in GitHub/CSI-5007/_notes/: _site
Files GitHub/code-CSI-5007/notes/_notes/sorting-algorithms.md and GitHub/CSI-5007/_notes/sorting-algorithms.md differ
diff -uEbdr GitHub/code-CSI-5007/notes/_notes/class-code.md GitHub/CSI-5007/_notes/class-code.md
--- GitHub/code-CSI-5007/notes/_notes/class-code.md	2018-06-18 19:56:47.084134647 -0400
+++ GitHub/CSI-5007/_notes/class-code.md	2018-06-18 20:36:22.772306089 -0400
@@ -602,7 +602,7 @@
 ```
 
 # Squaring without Multiplication
-### Iterative
+## Iterative
 ```py
 def sq_no_mult_0(n):
     n2 = 0
@@ -611,7 +611,7 @@
     return n2
 ```
 
-### Recursive
+## Recursive
 ```py
 def sq_no_mult_r(n, count = -1, n2 = 0):
     if count == 0:
@@ -622,7 +622,7 @@
         return sq_no_mult_r(n, count-1, n2 + n)
 ```
 
-### Iterative
+## Iterative
 ```py
 def sq_no_mult_1(n):
     #Assumes n = 2^k
@@ -648,6 +648,7 @@
         n4 += n3
     return n2 + n4
 ```
+
 # Unweighted Graph Algorithms
 ## Breadth First Search
 ```py
diff -uEbdr GitHub/code-CSI-5007/notes/_notes/class_notes/june_11.md GitHub/CSI-5007/_notes/class_notes/june_11.md
--- GitHub/code-CSI-5007/notes/_notes/class_notes/june_11.md	2018-06-18 19:56:47.088134546 -0400
+++ GitHub/CSI-5007/_notes/class_notes/june_11.md	2018-06-18 20:36:22.772306089 -0400
@@ -1,3 +1,8 @@
+---
+layout: post
+mathjax: true
+---
+
 # Must Know Algorithms
 Prim, Kruskal, Dijkstra
 
@@ -119,7 +124,7 @@
 * `p` is a permutation
 * `D` is distance matrix
 	* Throughout all TSP implementations in this course, it is using a matrix.
-	* If the existing graph is not complete, it is "made complete" by setting each nonexisting edge to $\infinity$
+	* If the existing graph is not complete, it is "made complete" by setting each nonexisting edge to $\infty$
 
 ### Tree Walking
 ```
@@ -136,7 +141,7 @@
 |Call|Runtime|
 |---|---|
 |`[]`|1|
-|[0],[1],...[n-1]|$n$|
+|`[0],[1],...[n-1]`|$n$|
 |`[2]->[2,0],[2,1],...[2,n-1]`|$n-1$|
 
 Runtime: $O(n!)$
Only in GitHub/code-CSI-5007/notes/_notes/class_notes: june_18
Only in GitHub/CSI-5007/_notes/class_notes: june-18
diff -uEbdr GitHub/code-CSI-5007/notes/_notes/dynamic-programming.md GitHub/CSI-5007/_notes/dynamic-programming.md
--- GitHub/code-CSI-5007/notes/_notes/dynamic-programming.md	2018-06-18 19:56:47.088134546 -0400
+++ GitHub/CSI-5007/_notes/dynamic-programming.md	2018-06-18 20:36:22.776305989 -0400
@@ -1,9 +1,57 @@
+---
+layout: post
+mathjax: true
+---
+- [Elements of Dynamic Programming](#elements-of-dynamic-programming)
+    - [Optimal Substructure](#optimal-substructure)
+        - [Finding the Optimal Substructure](#finding-the-optimal-substructure)
+- [Running Time](#running-time)
+    - [Subproblem Graph](#subproblem-graph)
+    - ["Bottom-Up"](#bottom-up)
+- [Memoized DP Algorithm](#memoized-dp-algorithm)
+    - [Runtime](#runtime)
+    - [Fibonacci](#fibonacci)
+        - [Runtime Analysis](#runtime-analysis)
+        - [Pseudocode](#pseudocode)
+
+# Elements of Dynamic Programming
+* For dynamic programming to apply, an optimization problem must have:
+    * Optimal substructure
+    * Overlapping subproblems
+
+## Optimal Substructure
+* Characterizing the structure of an optimal solution.
+* An optimal solution is built from optimal solutions to subproblems.
+* **Optimal Substructure**
+    * An optimal solution of a problem contains within it optimal solutions to subproblems.
+
+### Finding the Optimal Substructure
+* Keep the space as simple as possible and then expand it as necessary.
+1. Show that a solution to a problem consists of making a choice.  This choice leaves one or more subproblems to be solved.
+2. Suppose for the given problem, you are given the choice that leads to the optimal solution.
+    1. Given the choice, determine which subproblems ensue and how to best characterize the subproblems.
+    2. Show that solutions to the subproblems are themselves optimal.
+        1. Suppose that each of the subproblem solutions are not optimal and then derive a contradiction.
+
+# Running Time
+* Depends on the product of **the number of subproblems overall** and **how many choices we look at for each subproblem**
+
+## Subproblem Graph
+* An alternative way of analysis
+* Each vertex corresponds to a subproblem.
+* Choices are edges incident from that subproblem.
+
+## "Bottom-Up"
+* Optimal solutions to subproblems are found first.
+* Involves making a choice among subproblems as to which we will use in solving the problem.
+* The cost of the problem is the cost of the subproblem plus the cost of the choice itself.
+
 # Memoized DP Algorithm
 Recursion + memoization
 * Remember solutions and reuse solutions to subproblems that help solve the problem.
     * "Memo" comes from the idea of using a scratch pad or memo to log results (as you would in calculating an equation without memory) and using those answers to find the final answer.
 ## Runtime
-    * time = # of subproblems * the amount of time you spend per subproblem
+* time = # of subproblems * the amount of time you spend per subproblem
 
 ## Fibonacci
 ```
@@ -31,9 +79,6 @@
 
 Runtime = $\Theta(n)$
 
-## Bottom-up DP Algorithm
-* A recursive algorithm starts at the top and works its way down.
-
 ### Pseudocode
 * Uses a hash table for look up instead of function calls
 
@@ -49,4 +94,3 @@
 ```
 * Answers to subproblems are stored in a dictionary of $1...n$
 * The only answer cared about is `fib[n]` which is returned.
-
Only in GitHub/CSI-5007/_notes/: final.md
diff -uEbdr GitHub/code-CSI-5007/notes/_notes/graph-algorithms.md GitHub/CSI-5007/_notes/graph-algorithms.md
--- GitHub/code-CSI-5007/notes/_notes/graph-algorithms.md	2018-06-18 19:56:47.088134546 -0400
+++ GitHub/CSI-5007/_notes/graph-algorithms.md	2018-06-18 20:36:22.776305989 -0400
@@ -289,13 +289,13 @@
 
 ## Prim's Algorithm
 * Starts from one vertex and grows the rest of the tree one edge at a time until all vertices are included.
-* Greedy
+* [Greedy](algorithms-basics.md#greedy-algorithms)
 	* Repeatedly selects the smallest weight edge at a vertex.
 
-1. Start from a given vertex.
-2. With each iteration add a new vertex to the spanning tree.
+1. Start from a given vertex $s$
+    1. This is root of a spanning tree $T$
+2. With each iteration add a new vertex to the spanning tree $T$.
     1. Always add the lowest-weight edge linking a vertex in the tree to a vertex outside of the tree.
-        1. A boolean array tracks whether a vertex has already been added to the tree.
 
 ### Pseudocode
 ```
Only in GitHub/CSI-5007/_notes/: _site
diff -uEbdr GitHub/code-CSI-5007/notes/_notes/sorting-algorithms.md GitHub/CSI-5007/_notes/sorting-algorithms.md
--- GitHub/code-CSI-5007/notes/_notes/sorting-algorithms.md	2018-06-18 19:56:47.088134546 -0400
+++ GitHub/CSI-5007/_notes/sorting-algorithms.md	2018-06-18 20:36:22.776305989 -0400
@@ -2,6 +2,7 @@
 layout: post
 mathjax: true
 ---
+- [The Sorting Problem](#the-sorting-problem)
 - [Bubble Sort](#bubble-sort)
     - [Running Time](#running-time)
     - [Loop Invariant](#loop-invariant)
@@ -15,7 +16,7 @@
     - [Python Implementation](#python-implementation)
 - [Selection Sort](#selection-sort)
     - [Python Implementation](#python-implementation)
-- [Heap Sort](#heap-sort)
+- [Heapsort](#heapsort)
     - [Runtime](#runtime)
     - [Book Implementation](#book-implementation)
     - [Class Implementation](#class-implementation)
@@ -28,6 +29,17 @@
     - [Python Implementation](#python-implementation)
 - [Bin/Bucket Sort](#binbucket-sort)
 
+# The Sorting Problem
+**Input**: A sequence of $n$ numbers $\langle{a_1,a_2,...,a_n}\rangle$
+
+**Output**: A permutation of the sequence in increasing or decreasing order.
+    
+* **Ascending**
+    * $a_i \le a_{i+1}$ for all $1\le i<n$
+* **Descending**
+    * $a_i \ge a_{i+1}$ for all $1\le i<n$
+
+
 # Bubble Sort
 
 Compares each pair of elements in an array and swaps them if they are out of order until the entire array is sorted.
@@ -113,7 +125,7 @@
 
 ```
 
-# Heap Sort
+# Heapsort
 
 * A comparison based algorithm
 * Sorts in place
